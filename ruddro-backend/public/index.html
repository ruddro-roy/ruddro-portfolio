<script src="https://unpkg.com/satellite.js"></script>
<script src="https://threejs.org/build/three.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script>
const EARTH_RADIUS = 6371;
const SCALE = 0.0001;
const TRAIL_LENGTH = 20;
const ORBIT_STEPS = 360;
const UPDATE_INTERVAL = 5000;

// Three.js setup
const scene    = new THREE.Scene();
const camera   = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('renderer').appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

camera.position.z = EARTH_RADIUS * SCALE * 1.5;

// Earth
const loader = new THREE.TextureLoader();
const earthMaterial = new THREE.MeshPhongMaterial({
  map: loader.load('https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg'),
  normalMap: loader.load('https://threejs.org/examples/textures/earth_normal_2048.jpg'),
  emissiveMap: loader.load('https://threejs.org/examples/textures/earth_at_night_2048.jpg'),
  emissive: new THREE.Color(0x222222),
  emissiveIntensity: 0.8,
  shininess: 10
});
const earth = new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS * SCALE, 64, 64), earthMaterial);
scene.add(earth);
scene.add(new THREE.AmbientLight(0x404040));
const sun = new THREE.PointLight(0xffffff, 1.5);
sun.position.set(10000 * SCALE, 0, 0);
scene.add(sun);

// Satellite markers (instanced mesh)
const satGeometry = new THREE.SphereGeometry(5 * SCALE, 8, 8);
const satMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const satMesh     = new THREE.InstancedMesh(satGeometry, satMaterial, 10000);
scene.add(satMesh);
const dummy = new THREE.Object3D();

// Trails
const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
const trails = [];
for (let i = 0; i < 10000; i++) {
  const trailGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(TRAIL_LENGTH * 3);
  trailGeom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const trail = new THREE.Line(trailGeom, trailMaterial);
  scene.add(trail);
  trails.push({ geom: trailGeom, positions: pos, index: 0, visible: true });
}

// Orbits (preallocated but hidden)
const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
const orbits = [];
for (let i = 0; i < 10000; i++) {
  const orbitGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(ORBIT_STEPS * 3);
  orbitGeom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const orbitLine = new THREE.LineLoop(orbitGeom, orbitMaterial);
  orbitLine.visible = false;
  scene.add(orbitLine);
  orbits.push({ geom: orbitGeom, positions: pos });
}

// Debris (instanced)
const debrisGeom = new THREE.SphereGeometry(3 * SCALE, 4, 4);
const debrisMat  = new THREE.MeshBasicMaterial({ color: 0xff0000 });
const debrisInst = new THREE.InstancedMesh(debrisGeom, debrisMat, 500);
debrisInst.visible = false;
scene.add(debrisInst);

// State variables
let satData       = [];
let selectedSat   = null;
let autoRotate    = true;
let showTrails    = true;
let showOrbits    = false;
let showDebris    = false;

// Fetch satellite positions and update scene
async function updatePositions() {
  const res  = await fetch('/api/starlink/positions');
  const data = await res.json();
  satData    = data.sats;

  // Update instanced satellites
  for (let i = 0; i < satData.length; i++) {
    const sat = satData[i];
    dummy.position.set(sat.x * SCALE, sat.y * SCALE, sat.z * SCALE);
    dummy.updateMatrix();
    satMesh.setMatrixAt(i, dummy.matrix);

    // Update trail
    const t = trails[i];
    if (t) {
      if (showTrails) {
        t.geom.attributes.position.array.copyWithin(3, 0);
        t.geom.attributes.position.array[0] = sat.x * SCALE;
        t.geom.attributes.position.array[1] = sat.y * SCALE;
        t.geom.attributes.position.array[2] = sat.z * SCALE;
        t.geom.attributes.position.needsUpdate = true;
        trails[i].geom.visible = true;
      } else {
        trails[i].geom.visible = false;
      }
    }

    // Update orbit (only if showOrbits)
    if (showOrbits) {
      const orbit = orbits[i];
      if (orbit && !orbit.initialized) {
        // Compute 360 points along the orbit for this satellite
        const satrec = sat.satrec;
        const gmst   = satellite.gstime(new Date());
        for (let j = 0; j < ORBIT_STEPS; j++) {
          const tmin    = (j / ORBIT_STEPS) * sat.period * 60; // minutes to seconds
          const future  = new Date(Date.now() + tmin * 1000);
          const posVel  = satellite.propagate(satrec, future);
          if (posVel.position) {
            const eci  = posVel.position;
            const ecf  = satellite.eciToEcf(eci, gmst);
            orbit.positions[j*3]     = ecf.x * SCALE;
            orbit.positions[j*3 + 1] = ecf.y * SCALE;
            orbit.positions[j*3 + 2] = ecf.z * SCALE;
          }
        }
        orbit.geom.attributes.position.needsUpdate = true;
        orbit.initialized = true;
      }
      orbits[i].geom.visible = true;
    } else {
      orbits[i].geom.visible = false;
    }
  }
  satMesh.instanceMatrix.needsUpdate = true;

  // Debris (randomized if enabled)
  if (showDebris) {
    for (let i = 0; i < debrisInst.count; i++) {
      const phi   = Math.random() * Math.PI * 2;
      const theta = Math.random() * Math.PI;
      const r     = (EARTH_RADIUS + 2000 + Math.random() * 1000) * SCALE;
      dummy.position.set(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.sin(theta) * Math.sin(phi),
        r * Math.cos(theta)
      );
      dummy.updateMatrix();
      debrisInst.setMatrixAt(i, dummy.matrix);
    }
    debrisInst.visible = true;
  } else {
    debrisInst.visible = false;
  }

  // Update constellation summary stats
  document.getElementById('total-sats').textContent = satData.length;
  const shells = new Set(satData.map(s => Math.round(s.alt / 100)));
  document.getElementById('shells').textContent = shells.size;
  const avgAlt = satData.reduce((sum, s) => sum + s.alt, 0) / satData.length;
  document.getElementById('avg-alt').textContent = avgAlt.toFixed(0) + ' km';
  const avgVel = satData.reduce((sum, s) => sum + s.vel, 0) / satData.length;
  document.getElementById('avg-vel').textContent = avgVel.toFixed(2) + ' km/s';
  const avgPer = satData.reduce((sum, s) => sum + s.period, 0) / satData.length;
  document.getElementById('avg-period').textContent = '~' + (avgPer || 0).toFixed(1) + ' min';
  document.getElementById('last-update').textContent =
    new Date().toTimeString().split(' ')[0];

  // If a satellite is selected, plot GR trajectory (data.gr_sol)
  if (selectedSat !== null && data.gr_sol && data.gr_sol.length > 0) {
    const grGeom = new THREE.BufferGeometry();
    const grPos  = new Float32Array(data.gr_sol.length * 3);
    data.gr_sol.forEach((p, j) => {
      grPos[j * 3]     = p[0] * SCALE;
      grPos[j * 3 + 1] = p[1] * SCALE;
      grPos[j * 3 + 2] = p[2] * SCALE;
    });
    grGeom.setAttribute('position', new THREE.BufferAttribute(grPos, 3));
    const grLine = new THREE.Line(grGeom, new THREE.LineBasicMaterial({ color: 0xff00ff }));
    scene.add(grLine);
    document.getElementById('sat-gr-orbit').textContent =
      `GR Traj Points: ${data.gr_sol.length}`;
  }
}

// Raycaster for picking satellites
const raycaster = new THREE.Raycaster();
const mouseVec  = new THREE.Vector2();
renderer.domElement.addEventListener('click', (event) => {
  const rect = renderer.domElement.getBoundingClientRect();
  mouseVec.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouseVec.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouseVec, camera);

  // Test each satellite (simple loop; for performance you could spatially index)
  let closest = null;
  let minDist = Infinity;
  for (let i = 0; i < satData.length; i++) {
    const sat = satData[i];
    const pos = new THREE.Vector3(sat.x * SCALE, sat.y * SCALE, sat.z * SCALE);
    const dist = raycaster.ray.distanceToPoint(pos);
    if (dist < 0.005 && dist < minDist) {
      closest = { index: i, sat };
      minDist = dist;
    }
  }
  if (closest) {
    selectedSat = closest.index;
    const s = closest.sat;
    document.getElementById('detail-panel').style.display = 'block';
    document.getElementById('sat-name').textContent   = `Name: ${s.id}`;
    document.getElementById('sat-loc').textContent    =
      `Location: (${s.x.toFixed(0)}, ${s.y.toFixed(0)}, ${s.z.toFixed(0)}) km`;
    document.getElementById('sat-vel').textContent    = `Velocity: ${s.vel.toFixed(2)} km/s`;
    document.getElementById('sat-alt').textContent    = `Altitude: ${s.alt.toFixed(0)} km`;
    document.getElementById('sat-period').textContent = `Period: ${s.period.toFixed(1)} min`;
    // send request with selectedIdx for GR integration
    fetch(`/api/starlink/positions?selectedIdx=${closest.index}`)
      .then(r => r.json()).then(r => {
        if (r.gr_sol) {
          // will be rendered on next updatePositions call
        }
      });
  }
});

// Button handlers
document.getElementById('toggle-trails').addEventListener('click', () => {
  showTrails = !showTrails;
});
document.getElementById('toggle-orbits').addEventListener('click', () => {
  showOrbits = !showOrbits;
  // Force recomputation on next update
  orbits.forEach(o => (o.initialized = false));
});
document.getElementById('toggle-debris').addEventListener('click', () => {
  showDebris = !showDebris;
});
document.getElementById('toggle-auto-rotate').addEventListener('click', () => {
  autoRotate = !autoRotate;
  document.getElementById('auto-rotate-status').textContent =
    autoRotate ? 'Enabled' : 'Disabled';
});

// Warp to selected satellite
document.getElementById('warp-to-sat').addEventListener('click', () => {
  if (selectedSat !== null) {
    const s = satData[selectedSat];
    camera.position.set(
      s.x * SCALE * 2,
      s.y * SCALE * 2,
      s.z * SCALE * 2
    );
    controls.target.set(
      s.x * SCALE,
      s.y * SCALE,
      s.z * SCALE
    );
    controls.update();
  }
});

// Research mode panel
document.getElementById('research-mode').addEventListener('click', () => {
  const panel = document.getElementById('research-panel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
});

// Back link
document.getElementById('back').addEventListener('click', (e) => {
  e.preventDefault();
  window.location.href = '/';
});

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  if (autoRotate) {
    earth.rotation.y += 0.0001;
  }
  controls.update();
  renderer.render(scene, camera);
}

// Initial fetch and periodic updates
updatePositions();
setInterval(updatePositions, UPDATE_INTERVAL);
animate();

// Resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
