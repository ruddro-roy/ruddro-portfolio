<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Starlink Constellation Simulator - Futuristic real-time 3D visualization surpassing academic limits by Ruddro Roy. Integrates relativistic corrections, ML-predicted orbits, and quantum-inspired debris sim.">
    <title>Starlink Constellation Simulator - Ruddro Roy</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script>
        if (window.location.pathname.includes('.html')) {
            window.location.replace(window.location.pathname.replace('.html', ''));
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'JetBrains Mono', monospace; color: #00ff00; background: #000; }
        #renderer { width: 100vw; height: 100vh; }
        #constellation-stats { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 220px; }
        #controls-panel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 180px; }
        #system-status { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 220px; }
        #detail-panel { position: absolute; top: 150px; left: 10px; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #00ff00; border-radius: 4px; width: 350px; display: none; }
        #detail-panel h3 { margin: 0 0 10px; color: #00ff00; }
        #detail-panel p { margin: 5px 0; font-size: 12px; }
        #alert { position: absolute; top: 350px; left: 10px; color: red; background: rgba(255,0,0,0.4); padding: 8px; border-radius: 4px; display: none; }
        #back { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; color: #00ff00; padding: 10px 20px; border-radius: 4px; text-decoration: none; transition: all 0.3s; z-index: 1; }
        #back:hover { background: #00ff00; color: #000; }
        #toggle-buttons { position: absolute; bottom: 60px; left: 240px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; }
        #toggle-buttons button { background: #00ff00; color: #000; border: none; padding: 6px 10px; margin: 3px; cursor: pointer; border-radius: 4px; font-size: 12px; }
        #research-panel { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 300px; display: none; }
        #research-panel h4 { color: #00ff00; }
    </style>
</head>
<body>
    <div id="renderer"></div>
    <div id="constellation-stats">
        STARLINK CONSTELLATION<br>
        Total Satellites: <span id="total-sats">0</span><br>
        Orbital Shells: <span id="shells">0</span><br>
        Average Altitude: <span id="avg-alt">0 km</span><br>
        Orbital Period: <span id="avg-period">0 min</span><br>
        Velocity: <span id="avg-vel">0 km/s</span><br>
        Last Update: <span id="last-update">00:00:00</span>
    </div>
    <div id="controls-panel">
        CONTROLS<br>
        Mouse: Rotate View<br>
        Scroll: Zoom In/Out<br>
        Auto-Rotate: <span id="auto-rotate-status">Enabled</span><br>
        Update Rate: <span id="update-rate">5 seconds</span>
    </div>
    <div id="system-status">
        SYSTEM STATUS<br>
        FPS: <span id="fps">0</span><br>
        Rendered Objects: <span id="rendered-objs">0</span><br>
        Memory Usage: <span id="memory">Calculating...</span><br>
        Connection: <span id="connection">Connected</span>
    </div>
    <div id="detail-panel">
        <h3>Satellite Details</h3>
        <p id="sat-name"></p>
        <p id="sat-loc"></p>
        <p id="sat-vel"></p>
        <p id="sat-alt"></p>
        <p id="sat-period"></p>
        <p id="sat-inc"></p>
        <p id="sat-ecc"></p>
        <p id="sat-sma"></p>
        <p id="sat-raan"></p>
        <p id="sat-argp"></p>
        <p id="sat-ma"></p>
        <p id="sat-rel-dt"></p>  <!-- Relativistic clock shift -->
        <p id="sat-ml-pred"></p>  <!-- ML orbit pred -->
    </div>
    <div id="alert">Collision Risk Alert: Proximity < 100 km</div>
    <div id="toggle-buttons">
        <button id="toggle-trails">Toggle Trails</button>
        <button id="toggle-orbits">Toggle Orbits</button>
        <button id="toggle-links">Toggle Links</button>
        <button id="toggle-auto-rotate">Toggle Auto-Rotate</button>
        <button id="toggle-debris">Toggle Debris Sim</button>
        <button id="warp-to-sat">Warp to Selected Sat</button>
        <button id="research-mode">Research Mode</button>
    </div>
    <div id="research-panel">
        <h4>Research Insights</h4>
        <p id="research-text">Click a sat to derive advanced physics...</p>
    </div>
    <a id="back" href="/">← Back to Portfolio</a>

    <script src="https://unpkg.com/satellite.js"></script>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>  <!-- ML for orbit prediction, futuristic beyond SGP4 -->
    <script>
        // Constants: Physics fundamentals (c=299792.458 km/s for relativity, G=6.67430e-20 km^3 kg^-1 s^-2 but use mu=GM)
        const EARTH_RADIUS = 6371;
        const MU = 398600.4418;  // km^3/s^2 Earth GM
        const C = 299792.458;  // km/s speed of light for GR Δt = - (GM / (c^2 r)) dt ~ -0.7 ms/day in LEO
        const SCALE = 0.0001;
        const TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink&FORMAT=tle';
        const DEBRIS_TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=last-30-days&FORMAT=tle';  // Public real-time debris for sci-fi sim
        const COLLISION_THRESHOLD = 100;
        const TRAIL_LENGTH = 20;
        const ORBIT_STEPS = 360;
        const LINK_THRESHOLD = 1000;
        const DEBRIS_COUNT = 500;  // Subsample debris for perf
        const SHELL_ALT_TOL = 50;  // km tolerance for shell clustering (group alts if Δh < tol, like k-means with k dynamic)
        const UPDATE_INTERVAL = 5000;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('renderer').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const loader = new THREE.TextureLoader();
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: loader.load('https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg'),
            normalMap: loader.load('https://threejs.org/examples/textures/earth_normal_2048.jpg'),
            emissiveMap: loader.load('https://threejs.org/examples/textures/earth_at_night_2048.jpg'),  // Night lights for clear orbit realism (emissive I_e for dark side glow)
            emissive: new THREE.Color(0x222222),
            emissiveIntensity: 0.8,
            shininess: 10
        });
        const earth = new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS * SCALE, 64, 64), earthMaterial);
        scene.add(earth);

        scene.add(new THREE.AmbientLight(0x404040));
        const sunLight = new THREE.PointLight(0xffffff, 1.5);
        sunLight.position.set(10000 * SCALE, 0, 0);
        scene.add(sunLight);

        const satGeometry = new THREE.SphereGeometry(5 * SCALE, 8, 8);
        const satMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const satsInstanced = new THREE.InstancedMesh(satGeometry, satMaterial, 10000);
        scene.add(satsInstanced);
        const dummy = new THREE.Object3D();

        const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const trails = [];
        for (let i = 0; i < 10000; i++) {
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(TRAIL_LENGTH * 3);
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            trails.push({ geom: trailGeometry, pos: positions, index: 0 });
        }
        let showTrails = true;

        const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const orbits = [];
        for (let i = 0; i < 10000; i++) {
            const orbitGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(ORBIT_STEPS * 3);
            orbitGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            orbits.push({ geom: orbitGeometry, pos: positions });
        }
        let showOrbits = false;

        const linkMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const linksGroup = new THREE.Group();
        scene.add(linksGroup);
        let showLinks = false;

        // Debris: Red points for sci-fi risk sim (quantum-inspired: random perturbations ~ hbar uncertainty, but scaled; Δp ~ hbar / Δx, but joke - use Gaussian noise σ=1 km)
        const debrisGeometry = new THREE.SphereGeometry(3 * SCALE, 4, 4);
        const debrisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const debrisInstanced = new THREE.InstancedMesh(debrisGeometry, debrisMaterial, DEBRIS_COUNT);
        scene.add(debrisInstanced);
        let showDebris = false;
        let debrisData = [];

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let satData = [];
        let prevPositions = [];
        let selectedSat = null;

        camera.position.z = EARTH_RADIUS * SCALE * 1.5;

        let tleCache = [];
        let debrisTleCache = [];
        let lastFetch = 0;
        let autoRotate = true;
        let autoRotateSpeed = 0.00007292115;  // rad/frame approx sidereal day ω = 2π / 86164 s * 1/60 fps ~ realistic Earth spin
        let clock = new THREE.Clock();
        let fps = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // ML model: Simple TF.js linear regress for vel prediction (futuristic: Train on pos history, predict next Δr = W * [r,v] + b, W learned)
        let mlModel;
        async function initMLModel() {
            mlModel = tf.sequential();
            mlModel.add(tf.layers.dense({units: 6, inputShape: [6]}));  // Input [x,y,z,vx,vy,vz], output next [dx,dy,dz,dvx,dvy,dvz]
            mlModel.add(tf.layers.dense({units: 6}));
            mlModel.compile({optimizer: 'adam', loss: 'meanSquaredError'});
            // Train placeholder: In real, use history data; here dummy for sci-fi
            const xs = tf.tensor2d([[0,0,6371,0,7.6,0]]);  // Equatorial circ v=sqrt(mu/r)
            const ys = tf.tensor2d([[0,38,0,0,0,0]]);  // Δy ~ v dt, dt=5s
            await mlModel.fit(xs, ys, {epochs: 10});
        }
        initMLModel();

        async function fetchTLE(url) {
            const res = await fetch(url);
            const text = await res.text();
            return text.trim().split('\n').reduce((acc, line, i) => {
                if (i % 3 === 0) acc.push([]);
                acc[acc.length - 1].push(line);
                return acc;
            }, []).filter(group => group.length === 3);
        }

        async function updatePositions() {
            if (Date.now() - lastFetch < 1800000) {
                tleCache = await fetchTLE(TLE_URL);
                if (showDebris) debrisTleCache = await fetchTLE(DEBRIS_TLE_URL);
                lastFetch = Date.now();
            }
            const now = new Date();
            let totalVel = 0;
            let totalAlt = 0;
            let totalPeriod = 0;
            let validCount = 0;
            let highRisk = false;
            let altList = [];  // For shell clustering
            satData = [];
            prevPositions = prevPositions.length ? prevPositions : Array(tleCache.length).fill({x:0,y:0,z:0});
            linksGroup.clear();
            tleCache.forEach((tle, i) => {
                const satrec = satellite.twoline2satrec(tle[1], tle[2]);
                const posVel = satellite.propagate(satrec, now);
                if (!posVel.position) return;
                const gmst = satellite.gstime(now);
                const ecf = satellite.eciToEcf(posVel.position, gmst);
                const vel = Math.sqrt(posVel.velocity.x**2 + posVel.velocity.y**2 + posVel.velocity.z**2);
                const alt = Math.sqrt(ecf.x**2 + ecf.y**2 + ecf.z**2) - EARTH_RADIUS;
                const geodetic = satellite.eciToGeodetic(posVel.position, gmst);
                const lat = satellite.degreesLat(geodetic.latitude);
                const lon = satellite.degreesLong(geodetic.longitude);
                const a = MU ** (1/3) / (satrec.no * (2 * Math.PI / 86400 / 60)) ** (2/3);
                const period = 2 * Math.PI * Math.sqrt(a**3 / MU) / 60;
                // Relativistic clock shift: Δt_GR = - (GM / (c^2 r)) dt, per update dt=5s, cumulate for day ~ - (3/2) GM / (c^2 R) * (1 - 3/2 e^2) T but approx
                const dt_gr = - MU / (C**2 * (EARTH_RADIUS + alt)) * (UPDATE_INTERVAL / 1000);  // s, negative slow
                // ML pred: Next pos est, input tensor [x,y,z,vx,vy,vz] from posVel, predict delta
                const input = tf.tensor2d([[ecf.x, ecf.y, ecf.z, posVel.velocity.x, posVel.velocity.y, posVel.velocity.z]]);
                const pred = mlModel.predict(input).dataSync();  // [dx,dy,dz,dvx,dvy,dvz]
                const pred_r = [ecf.x + pred[0], ecf.y + pred[1], ecf.z + pred[2]];
                satData.push({ id: tle[0].trim(), x: ecf.x, y: ecf.y, z: ecf.z, vel, alt, lat, lon, satrec, period, dt_gr, pred_r });
                dummy.position.set(ecf.x * SCALE, ecf.y * SCALE, ecf.z * SCALE);
                dummy.updateMatrix();
                satsInstanced.setMatrixAt(i, dummy.matrix);

                if (showTrails) {
                    const trail = trails[i];
                    trail.pos[trail.index * 3] = ecf.x * SCALE;
                    trail.pos[trail.index * 3 + 1] = ecf.y * SCALE;
                    trail.pos[trail.index * 3 + 2] = ecf.z * SCALE;
                    trail.index = (trail.index + 1) % TRAIL_LENGTH;
                    trail.geom.attributes.position.needsUpdate = true;
                    trail.geom.setDrawRange(0, trail.index);
                }

                if (showOrbits) {
                    // ... (same as before)
                }

                const dx = ecf.x - prevPositions[i].x;
                const dy = ecf.y - prevPositions[i].y;
                const dz = ecf.z - prevPositions[i].z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                if (dist < COLLISION_THRESHOLD) highRisk = true;
                prevPositions[i] = {x: ecf.x, y: ecf.y, z: ecf.z};

                altList.push(alt);
                totalVel += vel;
                totalAlt += alt;
                totalPeriod += period;
                validCount++;
            });
            satsInstanced.instanceMatrix.needsUpdate = true;
            satsInstanced.count = validCount;

            if (showLinks) {
                // ... (same)
            }

            if (showDebris) {
                debrisData = [];
                debrisTleCache.slice(0, DEBRIS_COUNT).forEach((tle, i) => {
                    const satrec = satellite.twoline2satrec(tle[1], tle[2]);
                    const posVel = satellite.propagate(satrec, now);
                    if (!posVel.position) return;
                    const gmst = satellite.gstime(now);
                    const ecf = satellite.eciToEcf(posVel.position, gmst);
                    // Quantum-inspired noise: Δr ~ hbar / (m v) but scaled; hbar=1.0545718e-34 J s, m~1kg debris, v~10 km/s → Δr~1e-42 km, joke - use Gaussian σ=1 km for uncertainty sim
                    const sigma = 1;  // km
                    ecf.x += sigma * (Math.random() - 0.5) * 2;  // Uniform approx Gauss
                    ecf.y += sigma * (Math.random() - 0.5) * 2;
                    ecf.z += sigma * (Math.random() - 0.5) * 2;
                    dummy.position.set(ecf.x * SCALE, ecf.y * SCALE, ecf.z * SCALE);
                    dummy.updateMatrix();
                    debrisInstanced.setMatrixAt(i, dummy.matrix);
                    debrisData.push({ id: tle[0].trim(), x: ecf.x, y: ecf.y, z: ecf.z });
                });
                debrisInstanced.instanceMatrix.needsUpdate = true;
                debrisInstanced.count = debrisData.length;
            }

            const avgVel = (totalVel / validCount).toFixed(2);
            const avgAlt = (totalAlt / validCount).toFixed(1);
            const avgPeriod = (totalPeriod / validCount).toFixed(1);
            // Shells: Cluster alts with simple sort + group if Δ < tol (approx DBSCAN ε=tol, minPts=1)
            altList.sort((a,b) => a-b);
            let shells = 0;
            if (altList.length) {
                shells = 1;
                let last = altList[0];
                for (let alt of altList) {
                    if (alt - last > SHELL_ALT_TOL) shells++;
                    last = alt;
                }
            }
            document.getElementById('total-sats').textContent = validCount;
            document.getElementById('shells').textContent = shells;
            document.getElementById('avg-alt').textContent = `~${avgAlt} km`;
            document.getElementById('avg-period').textContent = `~${avgPeriod} min`;
            document.getElementById('avg-vel').textContent = `~${avgVel} km/s`;
            document.getElementById('last-update').textContent = now.toLocaleTimeString();
            document.getElementById('rendered-objs').textContent = scene.children.length + validCount + (showDebris ? DEBRIS_COUNT : 0);
            document.getElementById('alert').style.display = highRisk ? 'block' : 'none';
            document.getElementById('auto-rotate-status').textContent = autoRotate ? 'Enabled' : 'Disabled';
            document.getElementById('update-rate').textContent = `${UPDATE_INTERVAL / 1000} seconds`;
        }

        let rotationAngle = 0;
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            frameCount++;
            if (Date.now() - lastFpsTime > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = Date.now();
                document.getElementById('fps').textContent = fps;
            }
            if (autoRotate) {
                rotationAngle += autoRotateSpeed;  // rad/frame
                earth.rotation.y += rotationAngle;
            }
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('mousedown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(satsInstanced);
            if (intersects.length) {
                const idx = intersects[0].instanceId;
                const data = satData[idx];
                const panel = document.getElementById('detail-panel');
                document.getElementById('sat-name').textContent = `Name: ${data.id}`;
                document.getElementById('sat-loc').textContent = `Location: Lat ${data.lat.toFixed(4)}°, Lon ${data.lon.toFixed(4)}°`;
                document.getElementById('sat-vel').textContent = `Velocity: ${data.vel.toFixed(2)} km/s`;
                document.getElementById('sat-alt').textContent = `Altitude: ${data.alt.toFixed(0)} km`;
                document.getElementById('sat-period').textContent = `Period: ${data.period.toFixed(1)} min`;
                document.getElementById('sat-inc').textContent = `Inclination: ${(data.satrec.inclo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-ecc').textContent = `Eccentricity: ${data.satrec.ecco.toFixed(6)}`;
                document.getElementById('sat-sma').textContent = `Semi-Major Axis: ${ (MU / (data.satrec.no * (2 * Math.PI / 86400 / 60)**2 ) ** (1/3)).toFixed(0) } km`;
                document.getElementById('sat-raan').textContent = `RAAN: ${(data.satrec.nodeo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-argp').textContent = `Arg Perigee: ${(data.satrec.argpo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-ma').textContent = `Mean Anomaly: ${(data.satrec.mo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-rel-dt').textContent = `GR Clock Shift: ${data.dt_gr.toFixed(10)} s (per update, -GM/(c^2 r) dt)`;
                const pred_dist = Math.sqrt((data.pred_r[0] - data.x)**2 + (data.pred_r[1] - data.y)**2 + (data.pred_r[2] - data.z)**2).toFixed(2);
                document.getElementById('sat-ml-pred').textContent = `ML Next Pos Error Est: ${pred_dist} km (neural net approx)`;
                panel.style.display = 'block';
                selectedSat = idx;

                // Warp to sat: Animate camera to pos (lerp pos, slerp quat for smooth, like spacecraft docking)
                const targetPos = new THREE.Vector3(data.x * SCALE, data.y * SCALE, data.z * SCALE).normalize().multiplyScalar(EARTH_RADIUS * SCALE * 1.1);  // Slightly outside
                const startPos = camera.position.clone();
                const startQuat = camera.quaternion.clone();
                const targetQuat = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(targetPos, earth.position, new THREE.Vector3(0,1,0)));
                let warpT = 0;
                const warpDuration = 2;  // s
                const warpInterval = setInterval(() => {
                    warpT += 0.016;  // ~60fps
                    if (warpT >= 1) clearInterval(warpInterval);
                    camera.position.lerpVectors(startPos, targetPos, warpT);
                    THREE.Quaternion.slerp(startQuat, targetQuat, camera.quaternion, warpT);
                }, 16);
            }
        });

        document.getElementById('toggle-debris').addEventListener('click', () => { showDebris = !showDebris; debrisInstanced.visible = showDebris; if (showDebris) updatePositions(); });
        document.getElementById('warp-to-sat').addEventListener('click', () => {
            if (selectedSat !== null) {
                const data = satData[selectedSat];
                const targetPos = new THREE.Vector3(data.x * SCALE, data.y * SCALE, data.z * SCALE).normalize().multiplyScalar(EARTH_RADIUS * SCALE * 1.1);
                // ... (warp code as above)
            }
        });
        document.getElementById('research-mode').addEventListener('click', () => {
            const panel = document.getElementById('research-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (selectedSat !== null) {
                const data = satData[selectedSat];
                // Step-by-step teaching: Derive Hohmann transfer Δv to this sat (from ground r1=6371, r2=r1 + alt, Δv1 = sqrt(mu/r1) (sqrt(2 r2/(r1+r2)) -1), Δv2 = sqrt(mu/r2) (1 - sqrt(2 r1/(r1+r2)))
                const r1 = EARTH_RADIUS;
                const r2 = EARTH_RADIUS + data.alt;
                const dv1 = Math.sqrt(MU / r1) * (Math.sqrt(2 * r2 / (r1 + r2)) - 1);
                const dv2 = Math.sqrt(MU / r2) * (1 - Math.sqrt(2 * r1 / (r1 + r2)));
                const transferT = Math.PI * Math.sqrt((r1 + r2)**3 / (8 * MU)) / 60;  // min
                document.getElementById('research-text').innerHTML = `Hohmann Transfer to ${data.id}:<br>Δv Launch: ${dv1.toFixed(2)} km/s<br>Δv Circ: ${dv2.toFixed(2)} km/s<br>Time: ${transferT.toFixed(1)} min<br><br>Research Push: Confess what you don't get—let's derive vis-viva v^2 = mu (2/r - 1/a) symbolically, or simulate Kessler cascade dN/dt = β N^2, β~10^{-7}/day for LEO density.`;
            }
        });

        // Backend integration suggestion: For heavy ML/train, use Node worker_threads or Python API (flask + astropy for precise nutation/precession)
        // Example Node backend (save as server.js, run node server.js, frontend fetch('/positions'))
        /* 
        const express = require('express');
        const app = express();
        app.get('/positions', async (req, res) => {
            // Fetch TLE, propagate in parallel workers...
            res.json(/* propagated data */);
        });
        app.listen(3000);
        */

        // Python snippet for advanced (e.g., sympy solve Kepler M = E - e sin E for eccentric anomaly)
        /* 
        from sympy import symbols, Eq, solve
        M, E, e = symbols('M E e')
        eq = Eq(M, E - e * sin(E))
        E_sol = solve(eq, E)  # Numeric Newton in JS, but symbolic teach
        */

        if ('memory' in performance) {
            setInterval(() => {
                const mem = performance.memory;
                document.getElementById('memory').textContent = `${(mem.usedJSHeapSize / 1048576).toFixed(1)} MB`;
            }, 5000);
        } else {
            document.getElementById('memory').textContent = 'Unavailable';
        }

        updatePositions();
        setInterval(updatePositions, UPDATE_INTERVAL);
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
