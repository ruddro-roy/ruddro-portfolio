<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Starlink Constellation Simulator - Real-time 3D visualization of 8,000+ Starlink satellites by Ruddro Roy.">
    <title>Starlink Constellation Simulator - Ruddro Roy</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <script>
        if (window.location.pathname.includes('.html')) {
            window.location.replace(window.location.pathname.replace('.html', ''));
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'JetBrains Mono', monospace; color: #00ff00; background: #000; }  /* Terminal green on black */
        #renderer { width: 100vw; height: 100vh; }
        #constellation-stats { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 220px; }
        #controls-panel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 180px; }
        #system-status { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; font-size: 12px; width: 220px; }
        #detail-panel { position: absolute; top: 150px; left: 10px; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #00ff00; border-radius: 4px; width: 300px; display: none; }
        #detail-panel h3 { margin: 0 0 10px; color: #00ff00; }
        #detail-panel p { margin: 5px 0; font-size: 12px; }
        #alert { position: absolute; top: 300px; left: 10px; color: red; background: rgba(255,0,0,0.4); padding: 8px; border-radius: 4px; display: none; }
        #back { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; color: #00ff00; padding: 10px 20px; border-radius: 4px; text-decoration: none; transition: all 0.3s; z-index: 1; }
        #back:hover { background: #00ff00; color: #000; }
        #toggle-buttons { position: absolute; bottom: 60px; left: 240px; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #00ff00; border-radius: 4px; }
        #toggle-buttons button { background: #00ff00; color: #000; border: none; padding: 6px 10px; margin: 3px; cursor: pointer; border-radius: 4px; font-size: 12px; }
    </style>
</head>
<body>
    <div id="renderer"></div>
    <div id="constellation-stats">
        STARLINK CONSTELLATION<br>
        Total Satellites: <span id="total-sats">0</span><br>
        Orbital Shells: <span id="shells">0</span><br>
        Average Altitude: <span id="avg-alt">0 km</span><br>
        Orbital Period: <span id="avg-period">0 min</span><br>
        Velocity: <span id="avg-vel">0 km/s</span><br>
        Last Update: <span id="last-update">00:00:00</span>
    </div>
    <div id="controls-panel">
        CONTROLS<br>
        Mouse: Rotate View<br>
        Scroll: Zoom In/Out<br>
        Auto-Rotate: <span id="auto-rotate-status">Enabled</span><br>
        Update Rate: <span id="update-rate">5 seconds</span>
    </div>
    <div id="system-status">
        SYSTEM STATUS<br>
        FPS: <span id="fps">0</span><br>
        Rendered Objects: <span id="rendered-objs">0</span><br>
        Memory Usage: <span id="memory">Calculating...</span><br>
        Connection: <span id="connection">Connected</span>
    </div>
    <div id="detail-panel">
        <h3>Satellite Details</h3>
        <p id="sat-name"></p>
        <p id="sat-loc"></p>
        <p id="sat-vel"></p>
        <p id="sat-alt"></p>
        <p id="sat-period"></p>
        <p id="sat-inc"></p>
        <p id="sat-ecc"></p>
        <p id="sat-sma"></p>
        <p id="sat-raan"></p>
        <p id="sat-argp"></p>
        <p id="sat-ma"></p>
    </div>
    <div id="alert">Collision Risk Alert: Proximity < 100 km</div>
    <div id="toggle-buttons">
        <button id="toggle-trails">Toggle Trails</button>
        <button id="toggle-orbits">Toggle Orbits</button>
        <button id="toggle-links">Toggle Links</button>
        <button id="toggle-auto-rotate">Toggle Auto-Rotate</button>
    </div>
    <a id="back" href="/">← Back to Portfolio</a>

    <script src="https://unpkg.com/satellite.js"></script>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
        const EARTH_RADIUS = 6371;
        const MU = 398600.4418;  // km^3/s^2
        const SCALE = 0.0001;
        const TLE_URL = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink&FORMAT=tle';
        const COLLISION_THRESHOLD = 100;
        const TRAIL_LENGTH = 20;
        const ORBIT_STEPS = 360;
        const LINK_THRESHOLD = 1000;
        const SHELL_ALT_BINS = [300, 400, 500, 600, 700];  // km bins for shells (group by h, math: hist count non-zero)
        const UPDATE_INTERVAL = 5000;  // ms

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('renderer').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        const loader = new THREE.TextureLoader();
        const earth = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_RADIUS * SCALE, 64, 64),
            new THREE.MeshPhongMaterial({
                map: loader.load('https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg'),
                normalMap: loader.load('https://threejs.org/examples/textures/earth_normal_2048.jpg'),
                shininess: 10
            })
        );
        scene.add(earth);

        scene.add(new THREE.AmbientLight(0x404040));
        const sunLight = new THREE.PointLight(0xffffff, 1.5);
        sunLight.position.set(10000 * SCALE, 0, 0);
        scene.add(sunLight);

        const satGeometry = new THREE.SphereGeometry(5 * SCALE, 8, 8);
        const satMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const satsInstanced = new THREE.InstancedMesh(satGeometry, satMaterial, 10000);
        scene.add(satsInstanced);
        const dummy = new THREE.Object3D();

        const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const trails = [];
        for (let i = 0; i < 10000; i++) {
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(TRAIL_LENGTH * 3);
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            trails.push({ geom: trailGeometry, pos: positions, index: 0 });
        }
        let showTrails = true;

        const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const orbits = [];
        for (let i = 0; i < 10000; i++) {
            const orbitGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(ORBIT_STEPS * 3);
            orbitGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            orbits.push({ geom: orbitGeometry, pos: positions });
        }
        let showOrbits = false;

        const linkMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const linksGroup = new THREE.Group();
        scene.add(linksGroup);
        let showLinks = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let satData = [];
        let prevPositions = [];
        let selectedSat = null;

        camera.position.z = EARTH_RADIUS * SCALE * 1.5;

        let tleCache = [];
        let lastFetch = 0;
        let autoRotate = true;
        let autoRotateSpeed = 0.05;  // deg/frame ~ slow Earth sidereal ω=0.004167°/s * 60fps = 0.25°/frame, scaled down
        let clock = new THREE.Clock();  // For FPS Δt
        let fps = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        async function fetchStarlinkTLE() {
            if (Date.now() - lastFetch < 1800000) return tleCache;
            const res = await fetch(TLE_URL);
            const text = await res.text();
            tleCache = text.trim().split('\n').reduce((acc, line, i) => {
                if (i % 3 === 0) acc.push([]);
                acc[acc.length - 1].push(line);
                return acc;
            }, []).filter(group => group.length === 3);
            lastFetch = Date.now();
            document.getElementById('connection').textContent = 'Connected';
            return tleCache;
        }

        async function updatePositions() {
            const tles = await fetchStarlinkTLE();
            const now = new Date();
            let totalVel = 0;
            let totalAlt = 0;
            let totalPeriod = 0;
            let validCount = 0;
            let highRisk = false;
            let altHistogram = Array(SHELL_ALT_BINS.length).fill(0);  // Bin counts for shells
            satData = [];
            prevPositions = prevPositions.length ? prevPositions : Array(tles.length).fill({x:0,y:0,z:0});
            linksGroup.clear();
            tles.forEach((tle, i) => {
                const satrec = satellite.twoline2satrec(tle[1], tle[2]);
                const posVel = satellite.propagate(satrec, now);
                if (!posVel.position) return;
                const gmst = satellite.gstime(now);
                const ecf = satellite.eciToEcf(posVel.position, gmst);
                const vel = Math.sqrt(posVel.velocity.x**2 + posVel.velocity.y**2 + posVel.velocity.z**2);
                const alt = Math.sqrt(ecf.x**2 + ecf.y**2 + ecf.z**2) - EARTH_RADIUS;
                const geodetic = satellite.eciToGeodetic(posVel.position, gmst);
                const lat = satellite.degreesLat(geodetic.latitude);
                const lon = satellite.degreesLong(geodetic.longitude);
                const a = MU ** (1/3) / (satrec.no * (2 * Math.PI / 86400 / 60)) ** (2/3);  // semi-major km
                const period = 2 * Math.PI * Math.sqrt(a**3 / MU) / 60;  // min
                satData.push({ id: tle[0].trim(), x: ecf.x, y: ecf.y, z: ecf.z, vel, alt, lat, lon, satrec, period });
                dummy.position.set(ecf.x * SCALE, ecf.y * SCALE, ecf.z * SCALE);
                dummy.updateMatrix();
                satsInstanced.setMatrixAt(i, dummy.matrix);

                if (showTrails) {
                    const trail = trails[i];
                    trail.pos[trail.index * 3] = ecf.x * SCALE;
                    trail.pos[trail.index * 3 + 1] = ecf.y * SCALE;
                    trail.pos[trail.index * 3 + 2] = ecf.z * SCALE;
                    trail.index = (trail.index + 1) % TRAIL_LENGTH;
                    trail.geom.attributes.position.needsUpdate = true;
                    trail.geom.setDrawRange(0, trail.index);
                }

                if (showOrbits) {
                    const orbit = orbits[i];
                    const e = satrec.ecco;
                    const inc = satrec.inclo;
                    const raan = satrec.nodeo;
                    const argp = satrec.argpo;
                    for (let step = 0; step < ORBIT_STEPS; step++) {
                        const nu = (step / ORBIT_STEPS) * 2 * Math.PI;
                        const r_nu = a * (1 - e**2) / (1 + e * Math.cos(nu));
                        let x_orb = r_nu * (Math.cos(nu) * Math.cos(argp) - Math.sin(nu) * Math.sin(argp) * Math.cos(inc));
                        let y_orb = r_nu * (Math.cos(nu) * Math.sin(argp) + Math.sin(nu) * Math.cos(argp) * Math.cos(inc));
                        let z_orb = r_nu * (Math.sin(nu) * Math.sin(inc));
                        const x_eci = x_orb * Math.cos(raan) - y_orb * Math.sin(raan);
                        const y_eci = x_orb * Math.sin(raan) + y_orb * Math.cos(raan);
                        const z_eci = z_orb;
                        const x_ecf = x_eci * Math.cos(gmst) - y_eci * Math.sin(gmst);
                        const y_ecf = x_eci * Math.sin(gmst) + y_eci * Math.cos(gmst);
                        const z_ecf = z_eci;
                        orbit.pos[step * 3] = x_ecf * SCALE;
                        orbit.pos[step * 3 + 1] = y_ecf * SCALE;
                        orbit.pos[step * 3 + 2] = z_ecf * SCALE;
                    }
                    orbit.geom.attributes.position.needsUpdate = true;
                    orbit.geom.setDrawRange(0, ORBIT_STEPS);
                }

                const dx = ecf.x - prevPositions[i].x;
                const dy = ecf.y - prevPositions[i].y;
                const dz = ecf.z - prevPositions[i].z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                if (dist < COLLISION_THRESHOLD) highRisk = true;
                prevPositions[i] = {x: ecf.x, y: ecf.y, z: ecf.z};

                // Shell bin: Find index where alt < bin[k], count non-zero bins as shells
                for (let b = 0; b < SHELL_ALT_BINS.length; b++) {
                    if (alt < SHELL_ALT_BINS[b]) {
                        altHistogram[b]++;
                        break;
                    }
                }

                totalVel += vel;
                totalAlt += alt;
                totalPeriod += period;
                validCount++;
            });
            satsInstanced.instanceMatrix.needsUpdate = true;
            satsInstanced.count = validCount;

            // Links: Subsampled pairwise (every 50th for ~O((8000/50)^2) = 25k lines max)
            if (showLinks) {
                for (let i = 0; i < validCount; i += 50) {
                    for (let j = i + 50; j < validCount; j += 50) {
                        const sat1 = satData[i];
                        const sat2 = satData[j];
                        const dx = sat1.x - sat2.x;
                        const dy = sat1.y - sat2.y;
                        const dz = sat1.z - sat2.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        if (dist < LINK_THRESHOLD) {
                            const linkGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(sat1.x * SCALE, sat1.y * SCALE, sat1.z * SCALE),
                                new THREE.Vector3(sat2.x * SCALE, sat2.y * SCALE, sat2.z * SCALE)
                            ]);
                            const linkLine = new THREE.Line(linkGeom, linkMaterial);
                            linksGroup.add(linkLine);
                        }
                    }
                }
            }

            const avgVel = (totalVel / validCount).toFixed(2);
            const avgAlt = (totalAlt / validCount).toFixed(1);
            const avgPeriod = (totalPeriod / validCount).toFixed(1);
            const shells = altHistogram.filter(count => count > 0).length;  // Non-empty bins as shells
            document.getElementById('total-sats').textContent = validCount;
            document.getElementById('shells').textContent = shells;
            document.getElementById('avg-alt').textContent = `~${avgAlt} km`;
            document.getElementById('avg-period').textContent = `~${avgPeriod} min`;
            document.getElementById('avg-vel').textContent = `~${avgVel} km/s`;
            document.getElementById('last-update').textContent = now.toLocaleTimeString();
            document.getElementById('rendered-objs').textContent = scene.children.length + validCount;  // Approx: scene objs + instanced sats
            document.getElementById('alert').style.display = highRisk ? 'block' : 'none';
            document.getElementById('auto-rotate-status').textContent = autoRotate ? 'Enabled' : 'Disabled';
            document.getElementById('update-rate').textContent = `${UPDATE_INTERVAL / 1000} seconds`;
        }

        let rotationAngle = 0;
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            frameCount++;
            if (Date.now() - lastFpsTime > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = Date.now();
                document.getElementById('fps').textContent = fps;
            }
            if (autoRotate) {
                rotationAngle += autoRotateSpeed * delta * 60;  // Normalize to deg/s
                earth.rotation.y = rotationAngle * (Math.PI / 180);  // rad
            }
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('mousedown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(satsInstanced);
            if (intersects.length) {
                const idx = intersects[0].instanceId;
                const data = satData[idx];
                const panel = document.getElementById('detail-panel');
                document.getElementById('sat-name').textContent = `Name: ${data.id}`;
                document.getElementById('sat-loc').textContent = `Location: Lat ${data.lat.toFixed(4)}°, Lon ${data.lon.toFixed(4)}°`;
                document.getElementById('sat-vel').textContent = `Velocity: ${data.vel.toFixed(2)} km/s`;
                document.getElementById('sat-alt').textContent = `Altitude: ${data.alt.toFixed(0)} km`;
                document.getElementById('sat-period').textContent = `Period: ${data.period.toFixed(1)} min (T = 2π sqrt(a^3/mu))`;
                document.getElementById('sat-inc').textContent = `Inclination: ${(data.satrec.inclo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-ecc').textContent = `Eccentricity: ${data.satrec.ecco.toFixed(6)}`;
                document.getElementById('sat-sma').textContent = `Semi-Major Axis: ${ (MU / (data.satrec.no * (2 * Math.PI / 86400 / 60)**2 ) ** (1/3)).toFixed(0) } km`;
                document.getElementById('sat-raan').textContent = `RAAN: ${(data.satrec.nodeo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-argp').textContent = `Arg Perigee: ${(data.satrec.argpo * 180 / Math.PI).toFixed(2)}°`;
                document.getElementById('sat-ma').textContent = `Mean Anomaly: ${(data.satrec.mo * 180 / Math.PI).toFixed(2)}°`;
                panel.style.display = 'block';
                selectedSat = idx;
            }
        });

        document.getElementById('toggle-trails').addEventListener('click', () => { showTrails = !showTrails; trails.forEach(t => t.geom.parent.visible = showTrails); });
        document.getElementById('toggle-orbits').addEventListener('click', () => { showOrbits = !showOrbits; orbits.forEach(o => o.geom.parent.visible = showOrbits); if (showOrbits) updatePositions(); });
        document.getElementById('toggle-links').addEventListener('click', () => { showLinks = !showLinks; linksGroup.visible = showLinks; if (showLinks) updatePositions(); });
        document.getElementById('toggle-auto-rotate').addEventListener('click', () => { autoRotate = !autoRotate; document.getElementById('auto-rotate-status').textContent = autoRotate ? 'Enabled' : 'Disabled'; });

        if ('memory' in performance) {
            setInterval(() => {
                const mem = performance.memory;
                document.getElementById('memory').textContent = `${(mem.usedJSHeapSize / 1048576).toFixed(1)} MB`;
            }, 5000);
        } else {
            document.getElementById('memory').textContent = 'Unavailable';
        }

        updatePositions();
        setInterval(updatePositions, UPDATE_INTERVAL);
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
